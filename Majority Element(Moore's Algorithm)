Moore's VOTIMG Algo   *****Optimal

class Solution {
    public int majorityElement(int[] nums) {
        
        int count=0;
        int element=0 ;
   for(int i=0;i<nums.length;i++)
   {
       if(count==0)
       {
           count++;
           element=nums[i];
           
       }
       else if(nums[i] == element) count++;
       else count--;
   }
    int count2=0;
   for(int i=0;i<nums.length;i++)
   {
      
       if(element==nums[i]) count2++;
   }
   if (count2>nums.length/2) return element;
  return -1;
        
    }
}


****Brute*****
class Solution {
    public int majorityElement(int[] nums) {
        for(int i=0;i<nums.length;i++)
        {
            int count=0;
            for(int j=0;j<nums.length;j++)
            {
                if( nums[i]==nums[j] ) count++;
            }
            if(count>nums.length/2) return nums[i];
        }
        return -1;
        
    }
}

***Better******<using map>

class Solution {
    public int majorityElement(int[] nums) {
        HashMap<Integer,Integer> mpp=new HashMap<>();
        for(int i=0;i<nums.length;i++)
        {
            int count=mpp.getOrDefault(nums[i],0);
            mpp.put(nums[i],count+1);
        }
        for (Map.Entry<Integer, Integer> entry : mpp.entrySet()) {
            if (entry.getValue() > nums.length / 2) {
                return entry.getKey();
            }
        }
        return -1;
    }
}
